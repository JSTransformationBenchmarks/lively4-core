{"type":"Reference","version":"829fae14b71ae55fc2599fa03c7864034d7de91d","content":"import scriptManager from  \"src/client/script-manager.js\";\nimport files from \"../files.js\"\n\n// store promises of loaded and currently loading templates\nif (!self.lively4loadingPromises) {\n  // WARNING: only used by loadUnresolved and not loadByName\n  self.lively4loadingPromises = {} // just to be on the save side....\n}\nexport var loadingPromises = self.lively4loadingPromises;\n\nvar _loggingEnabled = false\nvar _log = function(...args) {\n  if (_loggingEnabled) {\n    console.log(\"ComponentLoader \",...args)\n  }\n}\n\nvar _timeEnabled = false\nvar _timeLog = function(name, msg, ...args) {\n  if (_timeEnabled) {\n    console.log(\"[component] \" + name + \" \" + Math.round(performance.now() - ComponentLoader.templateFirstLoadTimes[name]) +\"ms \"+ msg, ...args)\n  }\n}\n\n// for compatibility\nexport function register(componentName, template, prototype) {\n  return ComponentLoader.register(componentName, template, prototype);\n}\n\n/* #FutureWork should interactive state change of \"(module) global\" state be preserved while reloading / developing modules\n    ComponentLoader.foo = 3\n    ComponentLoader.foo\n\n#Discussion\n\npro) expected in Smalltalk-like developent and live-programmning experience\ncontra) gap between development-time and runtime (those manualy changes could make something work that without it won't...)\n\nsynthese) if modules and classes are also objects that can have run-time-specific state they should be migrated the same as objects. \n\n*/\n\n\n\nexport default class ComponentLoader {\n\n  static load() {\n    this._def(\"templates\", {});\n    this._def(\"prototypes\", {});\n    this._def(\"proxies\", {});\n    this._def(\"templatePathsCache\", {});\n    this._def(\"templatePathsCacheTime\", {});\n    this._def(\"templateFirstLoadTimes\", {}); \n  }\n  \n  static globalObject() {\n    window.lively4components = window.lively4components || {}\n    return window.lively4components\n  }\n  \n  static _def(name, init) {\n      Object.defineProperty(this, name, {\n        get() {\n          // Since, we want to keep state accross module reloading.... #PreserveState\n          var obj = this.globalObject()\n          if (!obj[name]) obj[name] = init;\n          return obj[name];\n        },\n        set(value) {\n          var obj = this.globalObject()\n          if (!obj[name]) obj[name] = value;\n        },\n        enumerable: true,\n        configurable: true\n      });\n  }\n\n  static updatePrototype(aClass, moduleName) {    \n    var componentName = moduleName.replace(/.*\\//,\"\").replace(/\\.js$/,\"\")\n    if (componentName && this.prototypes[componentName]) {\n      this.prototypes[componentName] = aClass\n      this.proxies[componentName].__proto__ = aClass\n      this.proxies[componentName].prototype.__proto__ = aClass.prototype\n    }\n  }\n\n  static async onCreatedCallback(object, componentName) {\n    _log('onCreatedCallback ' + componentName)\n      \n    // attach lively4scripts from the shadow root to this\n    if (this.shadowRoot)\n      scriptManager.attachScriptsFromShadowDOM(object);\n    \n    // attach lively4script from the instance\n    scriptManager.findLively4Script(object, false);\n\n    if (ComponentLoader.prototypes[componentName].createdCallback) {\n      ComponentLoader.prototypes[componentName].createdCallback.call(object);\n    }\n\n    // load any unknown elements, which this component might introduce\n    _log('START onCreatedCallback loadUnresolved ' + componentName)\n            \n    this._livelyLoading = Promise.resolve()\n    this._livelyLoadingDep =  ComponentLoader.loadUnresolved(\n        object, true, \"onCreated \" + componentName, false).then((args) => {\n      _log('FINISHED onCreatedCallback loadUnresolved ' + componentName)\n\n      // lively.fillTemplateStyles(object.shadowRoot, \"source: \" + componentName).then(() => {\n        // call the initialize script, if it exists\n      \n        if (typeof object.initialize === \"function\") {\n          object.initialize();\n        }\n        _log(\"dispatch created \" +componentName )\n        _log(\"Identitity: \" + (window.LastRegistered === object))\n        \n      // })\n      if (this.templateFirstLoadTimes[componentName]) {\n        _log('Component first load time: ' + ((performance.now() - this.templateFirstLoadTimes[componentName]) / 1000).toFixed(3) + \"s \" + componentName + \" \")\n        this.templateFirstLoadTimes[componentName] = null;\n      }\n      _log(\"[component loader] fire created \" + componentName)\n      object._lively4created = Date.now()\n      object.dispatchEvent(new Event(\"created\")); // when we wait on other unresolved components, we can run into cyclic dependencies.... #Cyclic\n    }).catch( e => {\n      console.error(e); \n      return e\n    });\n    this._livelyLoadingDep\n  }\n  \n  static async onAttachedCallback(object, componentName) {\n    \n    if (this._livelyLoading) {\n      await this._livelyLoading // should we provicde this robustness here? Or should these be more pure metal...\n    }\n    \n    _log(\"onAttachedCallback \" + componentName)\n    \n    if (object.attachedCallback && \n      ComponentLoader.proxies[componentName].attachedCallback != object.attachedCallback) {\n        object.attachedCallback.call(object);\n    } else if (ComponentLoader.prototypes[componentName].attachedCallback) {\n      ComponentLoader.prototypes[componentName].attachedCallback.call(object);\n    }\n  }\n  \n  static async onDetachedCallback(object, componentName) {\n    \n    if (this._livelyLoading) {\n      await this._livelyLoading\n    }\n    \n    if (object.detachedCallback \n    && ComponentLoader.proxies[componentName].detachedCallback != object.detachedCallback) {\n      object.detachedCallback.call(object);\n    } else if (ComponentLoader.prototypes[componentName].detachedCallback) {\n      ComponentLoader.prototypes[componentName].detachedCallback.call(object);\n    }\n  }\n  \n  static applyTemplate(element, componentName) {\n    var template = this.templates[componentName]\n    if (template) {\n      if (!element.shadowRoot) {\n        element.attachShadow({mode: 'open'});\n      }\n      \n      var fragment = template.cloneNode(true)\n      fragment.childNodes.forEach(ea => {\n        var clone = document.importNode(ea, true)\n        // #OriginTracking: attach meta infos here\n        element.shadowRoot.appendChild(clone)\n      })\n    }\n  }\n  \n  // this function registers a custom element,\n  // it is called from the bootstap code in the component templates\n  static async register(componentName, template, aClass) { \n    _log(\"[component loader] register \" + componentName)\n    var proxy\n    \n    // For reflection and debugging\n    this.templates[componentName] = template;\n    this.prototypes[componentName] = aClass;\n    \n    if (template) {\n      _log(\"[component loader] register fillTemplateStyles: \" + componentName)\n      await lively.fillTemplateStyles(template, \"source: \" + componentName)\n    }\n    \n    if (!this.proxies[componentName]) {\n      proxy = class extends HTMLElement {\n        static get name() {\n          return componentName\n        } \n        \n        get _lively4version() {\n          return 2\n        }\n        \n        constructor() {\n          _log(\"[component loader] Proxy Constructor \" + componentName)\n    \n          super(); // always call super() first in the constructor.\n          \n          ComponentLoader.applyTemplate(this, componentName)\n          ComponentLoader.onCreatedCallback(this, componentName)\n        }\n\n        connectedCallback( args) {\n          _log('connectedCallback ' + componentName )\n          \n          \n          // return super.connectedCallback(...args)\n          // super seams to bind early?\n          ComponentLoader.onAttachedCallback(this, componentName)\n          if (this.constructor.__proto__.prototype.connectedCallback) {\n            return this.constructor.__proto__.prototype.connectedCallback.apply(this, args)\n          }\n        }\n        disconnectedCallback(...args) {\n          _log('diconnectedCallback ' + componentName )\n          \n          // return super.disconnectedCallback(...args)\n          ComponentLoader.onDetachedCallback(this, componentName)\n          if (this.constructor.__proto__.prototype.disconnectedCallback) {\n            return this.constructor.__proto__.prototype.disconnectedCallback.apply(this, args)\n          }\n        }\n\n        adoptedCallback(...args)\t{\n          _log('adoptedCallback ' + componentName )\n          // return super.adoptedCallback(...args)\n          if (this.constructor.__proto__.prototype.adoptedCallback) {\n            return this.constructor.__proto__.prototype.adoptedCallback.apply(this, args)  \n          }\n        }\n      }\n      // set the prototype of the proxy the first time\n      // #Idea: use \"extemds aClass\" ?\n      //       proxy.__proto__ = aClass\n      //       proxy.prototype.__proto__ = aClass.prototype\n      \n      _log(\"[component loader] define component: \" + componentName)\n      window.customElements.define(componentName, proxy); // #WebComponent #Magic\n      this.proxies[componentName] =  proxy\n    } else {\n      proxy = this.proxies[componentName] \n      \n    }\n    \n    // change the prototype of the proxy\n    proxy.__proto__ = aClass\n    proxy.prototype.__proto__ = aClass.prototype\n  }\n\n  // this function loads all unregistered elements, starts looking in lookupRoot,\n  // if lookupRoot is not set, it looks in the whole document.body,\n  // if deep is set, it also looks into shadow roots\n  static loadUnresolved(lookupRoot, deep, debuggingHint, withChildren=false, withyourself=false) {\n    lookupRoot = lookupRoot || document.body;\n\n    var selector = \":not(:defined)\";\n    var unresolved = []\n    \n    // check if lookupRoot is unresolved\n    \n    // loot at me\n    if (withyourself && lookupRoot.parentElement) {\n      var unresolvedSiblingsAndMe = Array.from(lookupRoot.parentElement.querySelectorAll(selector));\n      if (unresolvedSiblingsAndMe.includes(lookupRoot)) {\n        unresolved.push(lookupRoot)\n      }\n    }\n    // find all unresolved elements looking downwards from lookupRoot\n    \n    // look at my children? \n    if (withChildren) {\n      unresolved = unresolved.concat(Array.from(lookupRoot.querySelectorAll(selector)));\n    }\n    \n    // look into the shadow?\n    if (deep) {\n      var deepUnresolved = findUnresolvedDeep(lookupRoot);\n      unresolved = unresolved.concat(deepUnresolved);\n    }\n\n    function findUnresolvedDeep(root) {\n      var shadow = root.shadowRoot;\n      if (!shadow) {\n        return [];\n      }\n\n      var result = Array.from(shadow.querySelectorAll(selector));\n\n      Array.from(shadow.children).forEach((child) => {\n        result = result.concat(findUnresolvedDeep(child));\n      });\n\n      return result;\n    }\n\n    // helper set to filter for unique tags\n    var unique = new Set();\n    \n    \n    var __debugOpenPromisedComponents = new Set()\n    \n    var promises = unresolved.filter((el) => {\n      // filter for unique tag names\n      if (!el.nodeName || el.nodeName.toLowerCase() == \"undefined\") return false;\n      var name = el.nodeName.toLowerCase();\n      return !unique.has(name) && unique.add(name);\n    })\n    .map((el) => {\n      var name = el.nodeName.toLowerCase();\n      if (loadingPromises[name]) {\n        // the loading was already triggered\n        return loadingPromises[name];\n      }\n\n      __debugOpenPromisedComponents.add(name)\n      // create a promise that resolves once el is completely created\n      var createdPromise = new Promise((resolve, reject) => {\n        if (el._lively4created) {\n          return resolve({target: el})\n        }\n        el.addEventListener(\"created\", (evt) => {\n          evt.stopPropagation();\n          __debugOpenPromisedComponents.delete(name)\n          resolve(evt);\n        });\n      });\n\n      // trigger loading the template of the unresolved element\n      loadingPromises[name] = createdPromise;\n      \n      loadingPromises[name].name = \"[Loaded \" +name + \" \" + Date.now() + \"]\"\n      \n      this.loadByName(name).then((didInsertTag) => {\n        if(!didInsertTag) {\n          console.error(\"Component Loader\", `Template ${name} could not be loaded.`, 3, null, \"yellow\");\n          delete loadingPromises[name];\n          return null;\n        }\n      })\n      \n\n      return createdPromise;\n    })\n    .filter(promise => promise != null);\n    \n    _log(\"findUnresolvedDeep components: \", promises)\n\n    // return a promise that resolves once all unresolved elements from the unresolved-array\n    // are completely created\n    return new Promise( (resolve, reject) => {\n      \n      // fuck promises!!!! I hate them. There is one promise pending.... but just does not fail. It just hangs around doing nothing! #Jens\n      promises.forEach( p => {\n        p.then( r => {\n          p.finished = true;\n        }, er => console.log(\"ERROR in promise: \" + p.name))\n        \n      })\n      window.setTimeout( function() {\n        var unfinished = false;\n        var unfinishedPromise;\n        promises.forEach( p => {\n          if (!p.finished) {\n            unfinishedPromise = p\n            unfinished = true;\n          }\n        })\n        if (unfinished) {\n          resolve(\"timeout\") // \"(if) the fuel gauge breaks, call maintenance. If they are not there in 20 minutes, fuck it.\"\n          console.warn(\"Timout due to unresolved promises, while loading \" + unfinishedPromise.name + \" context: \" + debuggingHint, \" unresolved: \" + Array.from(__debugOpenPromisedComponents).join(\", \") )\n        }\n      }, 20 * 1000)\n\n      Promise.all(promises).then( result => resolve(), err => {\n          _log(\"ERROR loading component \", err)\n      })\n    })\n  }\n  \n  \n  static resetTemplatePathCache() {\n    this.templatePaths = undefined\n    this.templatePathsCache = undefined\n    this.templatePathsCacheTime = undefined\n  }\n\n  static async getTemplatePathContent(path) {\n    \n   \n    \n    let cacheInvalidationTime = 60 * 5 * 1000;\n    let cached = this.templatePathsCache[path]\n    let time = this.templatePathsCacheTime[path]\n    if (cached && ((Date.now() - time) < cacheInvalidationTime)) return cached\n    \n    let resultPromise =  fetch(path, { method: 'OPTIONS' }).then(resp => {\n      if (resp.status !== 200) return undefined\n      return resp.json()\n    });\n    this.templatePathsCacheTime[path] = Date.now()\n    this.templatePathsCache[path] = new Promise(async (resolve, reject) => {\n      let result = await resultPromise;\n      if (result) {\n          resolve({contents: result.contents});\n        return cached \n      }\n    })\n    return resultPromise \n  }\n  \n  static getTemplatePaths() {\n    if (!this.templatePaths) {\n      const defaultPaths = [ // default\n        lively4url + '/templates/',\n        lively4url + '/src/components/',\n        lively4url + '/src/components/widgets/',\n        lively4url + '/src/components/tools/',\n        lively4url + '/src/components/halo/',\n        lively4url + '/src/components/demo/',\n        lively4url + '/src/components/draft/',\n        lively4url + '/src/components/d3/',\n        lively4url + '/src/client/vivide/components/',\n        lively4url + '/src/client/reactive/components/rewritten/',\n        lively4url + '/src/client/reactive/components/basic/',\n        lively4url + '/src/client/triples/components/',\n        lively4url + '/src/client/pen-editor/components/',\n        lively4url + '/src/babylonian-programming-editor/',\n        lively4url + '/src/babylonian-programming-editor/demos/canvas/',\n        lively4url + '/src/babylonian-programming-editor/demos/todo/',\n        lively4url + '/src/client/reactive/components/rewritten/conduit/src/components/',\n        lively4url + '/src/client/reactive/components/rewritten/conduit/rpComponents/',\n        lively4url + '/src/mpm-debugger/components/',\n      ];\n\n      const customPaths = this.persistentCustomTemplatePaths\n        .map(path => path.startsWith('/') ? lively4url + path : path);\n\n      this.templatePaths = defaultPaths.concat(customPaths); \n    } \n    return this.templatePaths;\n  }\n\n  /*MD ### PersistentCustomPaths MD*/\n  static get persistentCustomTemplatePaths() {\n    return JSON.parse(localStorage.lively4customTemplatePaths || '[]')\n  }\n\n  static set persistentCustomTemplatePaths(paths) {\n    localStorage.lively4customTemplatePaths = JSON.stringify(paths);\n    this.resetTemplatePathCache();\n  }\n\n  static addPersistentCustomTemplatePath(path) {\n    const customPaths = this.persistentCustomTemplatePaths;\n\n    if (!customPaths.includes(path)) {\n      customPaths.push(path);\n      this.persistentCustomTemplatePaths = customPaths;\n    }\n  }\n\n  static removePersistentCustomTemplatePath(path) {\n    const customPaths = this.persistentCustomTemplatePaths;\n\n    const index = customPaths.indexOf(path);\n    if (index > -1) {\n      customPaths.splice(index, 1);\n      this.persistentCustomTemplatePaths = customPaths;\n    }\n  }\n\n  static async searchTemplateFilename(filename) {\n    \n    var templatePaths =  this.getTemplatePaths()\n    let templateDir = undefined;          \n  \n    // #IDEA, using HTTP HEAD could be faster, but is not always implemented... as ource OPTIONS is neigher\n    // this method avoids the 404 in the console.log\n    \n    // the OPTIONS request seems to break karma... waits to long..\n    if (!window.__karma__) { \n      for(templateDir of templatePaths) {\n        try {\n          var stats = await this.getTemplatePathContent(templateDir);\n          var found = stats.contents.find(ea => ea.name == filename)\n        } catch(e) {\n          _log(\"searchTemplateFilename: could not get stats of  \" + filename + \" ERROR: \", e)\n          found = null\n        }\n        if (found) {\n          return templateDir + filename\n        }\n      }\n\n    } else {\n      // so the server did not understand OPTIONS, so lets ask for the files directly\n      if (!found) {\n        for(templateDir of templatePaths) {\n          found = await fetch(templateDir + filename, { method: 'GET' }) // #TODO use HEAD, after implementing it in lively4-server\n            .then(resp => resp.status == 200); \n          if (found) {\n            return templateDir + filename\n          }  \n        } \n      }      \n    }\n    return undefined\n  }\n  \n  // #TODO use loadingPromises here... #Issue, as we used it in livley.js directly, we loaded lively-window in parralel... \n  static async loadByName(name) {\n    _log(\"[component loader] loadByName \" + name)\n    \n    this.templateFirstLoadTimes[name] = performance.now()\n    var modUrl = await this.searchTemplateFilename(name + '.js')\n    if (!modUrl) {\n      throw new Error(\"Could not find template for \" + name)\n    }\n    _timeLog(name, \" found module filename\")\n    \n    // #OriginTracking: get source code information here\n    var templateURL = await this.searchTemplateFilename(name + '.html')\n    _timeLog(name, \" found template filename\")\n    \n    // Check  if the template will be loadable (this would e.g. fail if we were offline without cache)\n    // We have to check this before inserting the link tag because otherwise we will have\n    // the link tag even though the template was not properly loaded\n    try {\n      if(files.exists(modUrl)) {\n        _timeLog(name, \"module exists\")\n        var mod = await System.import(modUrl)\n        _timeLog(name, \"module loaded\")\n        var aClass = mod.default\n        \n        if (templateURL) {\n          if(files.exists(templateURL)) {\n            _timeLog(name, \"template exits\")\n            var templateSource = await fetch(templateURL).then(r => r.text());\n            _timeLog(name, \"template loaded\")\n            var div = document.createElement(\"div\")\n            div.innerHTML = templateSource\n            var template = div.querySelector(\"template\")\n            template.remove()\n          }          \n        }\n        this.register(name, template && template.content, aClass)\n        _timeLog(name, \"registered\")\n        return true;\n      } else {\n        return false;\n      }\n    } catch (error) {\n      return false;\n    }\n  }\n  \n  // #TODO refactor this to use lively.create(), because this is not enough... \n  static createComponent(tagString) {\n    var comp = document.createElement(tagString);\n    return comp;\n  }\n  \n  static openIn(parent, component, beginning) {\n    var created = false;\n    var compPromise = new Promise((resolve) => {\n      if (component._lively4created ) return resolve(component)\n      \n      component.addEventListener(\"created\", (e) => {\n        if (e.composedPath()[0] !== component) {\n          _log(\"[components] ingnore and stop created event from child \" + e.composedPath[0].tagName);\n          return \n        }\n        if (created) {\n          // #Just check... we had this issue before\n          throw new Error(\"[compontents] created called twice for \" + component)\n        } else {\n          created = true\n          e.stopPropagation();\n          resolve(e.target);\n        }\n        \n      });\n    });\n\n    if (beginning) {\n      parent.insertBefore(component, parent.firstChild);\n    } else {\n      parent.appendChild(component);\n    }\n    this.loadUnresolved(component, true, \"openIn \" + component, true, true);\n    return compPromise;\n  }\n\n  static openInBody(component) {\n    return this.openIn(document.body, component, true);\n  }\n\n  static async openInWindow(component, pos) {\n    // this will call the window's createdCallback before\n    // we append the child, if the window template is already\n    // loaded\n    var w = this.createComponent(\"lively-window\");\n    if (pos) {\n      lively.setPosition(w, pos);\n    }\n    w.style.opacity = 0.2\n    w.appendChild(component);\n\n    this.openInBody(w);\n\n    if (!component.localName.match(/-/)) {\n      return w // standard elments... which are no components\n    }\n    \n    // therefore, we need to call loadUnresolved again after\n    // adding the child, so that it finds it and resolves it,\n    // if it is currently unresolved\n    var windowPromise = new Promise((resolve) => {\n      this.loadUnresolved(document.body, true, \"openInWindow \" + component).then(() => {\n        w.style.opacity = 1.0\n        this.ensureWindowTitle(component, w)\n\n        resolve(w);\n      });\n    });\n\n    return windowPromise;\n  }\n  \n  static ensureWindowTitle(component, w) {\n    if (component.windowTitle) {\n      w.setAttribute('title', '' + component.windowTitle);\n    }\n  }  \n\n  static reloadComponent(source) {\n    var template = lively.html.parseHTML(source).find(ea => ea.localName == \"template\");\n    if (!template) return;\n    var name = template.id;\n    if (!name) return;\n    var templateClone = document.importNode(template.content, true);\n    ComponentLoader.templates[name] = templateClone;\n    \n    return lively.fillTemplateStyles(templateClone, \"source: \" + name).then( () => name);\n  }\n  \n}\n\nComponentLoader.load()\nComponentLoader.resetTemplatePathCache()\n"}