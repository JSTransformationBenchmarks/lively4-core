{"type":"Reference","version":"856225ee02fb281e2bb0b35a233b6682d1fd9024","content":"import _ from 'src/external/lodash/lodash.js'\nimport diff from 'src/external/diff-match-patch.js';\nconst dmp = new diff.diff_match_patch();\nimport Github from \"src/client/github.js\"\n\nimport { uuid as genUUID } from 'utils';\n\nimport tinycolor from 'src/external/tinycolor.js';\n\n\nexport class Annotation {\n  constructor(config) {\n    this.from = 0, // starts here...\n    this.to =  0  // stops before \n    Object.keys(config).forEach(key => {\n      this[key] = config[key]\n    })\n  }\n  \n  equalsRegion(region) {\n    return this.from == region.from && this.to == region.to\n  } \n  \n  equals(annotation) {\n    // do not check for classes.. we should also compare to structurally indentical objects?\n    // if (!(annotation instanceof Annotation)) return false;\n    \n    for(let key of Object.keys(this)) {\n      if (this[key] != annotation[key]) return false\n    }\n    // and the other way around....\n    for(let key of Object.keys(annotation)) {\n      if (this[key] != annotation[key]) return false\n    }\n    return true\n  }\n  \n  get length() {\n    return this.to - this.from\n    \n  }\n  \n  codeMirrorMark(cm) {\n    var color = this.color || \"lightgray\"\n    \n    color = tinycolor(color)\n    color.setAlpha(0.4)\n\n    \n    var fromPos = cm.posFromIndex(this.from)\n    var toPos = cm.posFromIndex(this.to)\n      \n    var marker = cm.markText(fromPos, toPos, \n      {\n        className: \"lively-annotation\",\n        attributes: {\n          \"data-annotation\": JSON.stringify(this)\n        },\n        css: `background-color: ${color.toString()}`});\n    return marker\n  }\n  \n  annotateInDOM(node, pos=0, parent) {\n    var annotation = this\n    if (node instanceof Text) {\n      var from = pos\n      var to = from + node.length\n      var intersection = annotation.intersectRegion({from, to})\n      if (intersection && parent) {\n        // lively.notify(\"replace from \" + intersection.from  + \" to \" + intersection.to)\n        var s = node.textContent\n        var a  = intersection.from - pos\n        var b  = intersection.to - pos\n        parent.insertBefore(new Text(s.slice(0, a )), node)\n        var style = `text-decoration-color: ${annotation.color};`\n        var replacement = <u style={style}>{s.slice(a, b)}</u>\n        parent.insertBefore(replacement, node)\n        var rest = new Text(s.slice(b, s.length))\n        parent.insertBefore(rest, node)\n        node.remove()\n      }\n      pos = to\n    } else {\n      for(var ea of Array.from(node.childNodes)) {\n        pos = this.annotateInDOM(ea, pos,  node)\n      }\n    }\n    return pos\n  }\n  \n  intersectRegion(region) {\n    if (this.to < region.from) return null\n    if (region.to < this.from) return null\n    return {from: Math.max(this.from, region.from), to: Math.min(this.to, region.to)}\n  }\n  \n  isInRegion(region) {\n    // could alternatively use insersectRegion ...\n    return region.from < this.to && this.to < region.to \n      || region.from <= this.from && this.from < region.to;\n  }\n  \n  cutRegion(region) {\n    var intersection = this.intersectRegion(region)\n    if (!intersection) return this\n    if (this.equalsRegion(intersection)) return null // cut complete\n    if (intersection.from == this.from) {\n      this.from = intersection.to\n      return this\n    } else if (intersection.to == this.to) {\n      this.to = intersection.from\n      return this\n    } else {\n      // split annotation\n      var rest = this.clone()\n      this.to = intersection.from\n      rest.from = intersection.to\n      return [this, rest] // and here we #Alias, annotations should deal with this with indirection \n                          // (e.g. ids that point to the real data if necessary)\n    }\n  }\n}\n\nexport default class AnnotationSet {\n\n  constructor(annotationsAndVersions=[]) {\n    this.list = [];\n    this.reference;\n    for(let ea of annotationsAndVersions) {\n      if (ea.type == \"Reference\") {\n        this.textVersion = ea.version // multiple text references per annotations file not (yet) supported \n        this.textContent = ea.content\n      } else {\n        this.add(ea)\n      }\n    }\n  }\n  \n  *[Symbol.iterator] () {\n    for(var ea of this.list) {\n      yield ea;  \n    }  \n  }\n\n  get size() {\n    return this.list.length\n  }\n  \n  add(annotation) {\n    if (!this.has(annotation)) {\n      this.list.push(new Annotation(annotation))\n    }\n  }\n\n  addAll(annotations) {\n    for(let ea of annotations) {\n      this.add(ea)\n    }\n  }\n\n  remove(annotation) {\n    this.list = this.list.filter(ea => !ea.equals(annotation))\n  }\n\n  removeAll(annotations) {\n    this.list = this.list.filter(ea => !annotations.has(ea))\n  }\n\n\n  equals(other) {\n    if (this.size != other.size) return false\n    for(let ea of this) {\n      if (!other.has(ea)) return false\n    }\n    return true\n  }\n/*MD # Design Challenge\n\nWhat should a \"diff\" of annotations actually look like?\n\nshould it be based on the Set semantics... and actually look for identical annotations, \ne.g. same \"from\" and \"to\" and same payload..\n\nOr should we split up the text annotations in regions... and normalize the annotations through that way?\n\nHow do we deal with \"duplicates\" and or overlapping \"annotations\" in the first place...\n\n\n\nMD*/\n\n  \n  mergeWithTransform(mytransformDiff, other, otherTransformDiff, parent, parentTransformDiff) {\n    var transformedMe = this.applyTextDiff(mytransformDiff)\n    var transformedOther = otherTransformDiff.applyTextDiff(otherTransformDiff)\n    var transformedParent = this.applyTextDiff(parentTransformDiff)\n    return transformedMe.merge(transformedOther, transformedParent)\n  }\n\n\n  merge(other, lastCommonParent) {\n    // {from, to} of {this, other, lastCommonParent} reference same text    \n\n    var diffA = lastCommonParent.diff(this)\n    var diffB = lastCommonParent.diff(other)\n  \n    var result = lastCommonParent.clone()\n    result.removeAll(diffA.del)\n    result.removeAll(diffB.del)\n    result.addAll(diffA.add)\n    result.addAll(diffB.add)\n    \n    return result\n  }\n\n  diff(otherAnnotationSet) {\n    var result = this.compare(otherAnnotationSet)\n    \n    // #TODO \n    // compare is very basic... some of the added and deleteted might be mutatated?\n\n    return result\n    \n  }\n\n  has(annotation) {\n    // #TODO #Performance bug... lineas with complex equals...\n    let found =  this.list.find(ea => ea.equals(annotation)) \n    return found ? true : false\n  }\n\n\n  // basic comparison... of actual annotations...\n  compare(b) {\n    var a = this\n    var same = new AnnotationSet()\n    var add = new AnnotationSet()\n    var del = new AnnotationSet()\n    for(let ea of a) {\n      if (b.has(ea)) {\n        same.add(ea)\n      } else {\n        del.add(ea)\n      }\n    }\n    for(let ea of b) {\n      if (!same.has(ea)) {\n        add.add(ea)\n      }\n    }\n    return {same, add, del}\n  } \n\n  removeFromTo(from, to) {\n    var region = {from, to}\n    for(let ea of this) {\n      var intersection = ea.intersectRegion(region)\n      if (intersection) {\n        var result = ea.cutRegion(intersection)\n        if (result == null) {\n          this.remove(ea)\n        } else if (result == ea) {\n          // do nothing\n        }else if (result.length == 2) {\n          this.add(result[1]) // we are cut in half\n        }\n      } \n    }\n  }\n  \n  annotationsInRegion(region = {from: 0, to:0, content: \"\"}) {\n    var result = new Set()\n    for(let ea of this) {\n      if (this.isInRegion(region, ea)) {\n        this.add(ea)       \n      }\n    }\n    return result\n  }\n\n  applyTextDiff(textDiff) {\n    let pos = 0;\n    for (let change of textDiff) {\n      let isAdd = change[0] == 1;\n      let isDel = change[0] == -1;\n      let isSame = change[0] == 0;\n      let length = change[1].length;\n      let newpos = pos + length;\n      let delOrAdd = isDel ? -1 : 1;\n      if (isAdd || isDel) {\n        for (let annotation of this.list) {\n\n          // simplest implementation... just grow and shrink with the diff\n          if (pos <= annotation.from) {\n            annotation.from += delOrAdd * length;\n          }\n          if (pos <= annotation.to) {\n            annotation.to += delOrAdd * length;\n          }\n        }\n      }\n      if (isAdd || isSame) {\n        pos = newpos;\n      }\n    }\n  }\n\n  toJSON() {\n    return JSON.stringify(this.list);\n  }\n\n  toJSONL() {\n    var config = []\n    if (this.textVersion ||  this.textContent) {\n      config.push({type: \"Reference\", version: this.textVersion, content: this.textContent})\n    }\n    return config.concat(this.list).map(ea => JSON.stringify(ea)).join(\"\\n\");    \n  }\n\n  toXML(text) {\n    let regions = this.regions(text);\n    var xml = regions.map(ea => {\n      var s = ea.content;\n      for(let annotation of this) {\n        if (annotation.isInRegion(ea)) {\n          s = `<${annotation.name}>${s}</${annotation.name}>`;\n        }\n      }\n      return s;\n    }).join(\"\");\n    return xml;\n  }\n\n  static fromJSONL(source) {\n    var list = source.split(\"\\n\").map(ea => {\n      try{ \n        return JSON.parse(ea) \n      } catch(e) {\n        console.warn(\"[annotations] could not parse linke: \" + ea)\n      }\n    }).filter(ea => ea)\n    return new AnnotationSet(list)\n  }\n\n  regions(text) {\n    var splitters = new Set();\n    this.list.forEach(ea => {\n      splitters.add(ea.from);\n      splitters.add(ea.to);\n    });\n    if (text) {\n      splitters.add(text.length);\n    }\n    splitters = Array.from(splitters).sort((a, b) => a-b);\n    var regions = [];\n    var last = 0;\n\n    for (var pos of splitters) {\n      regions.push({ from: last, to: pos, content: text && text.slice(last, pos) });\n      last = pos;\n    }\n\n    return regions;\n  }\n  \n\n  clearCodeMirrorMarks(cm) {\n    cm.getAllMarks().forEach(ea => ea.clear())\n  }\n\n  renderCodeMirrorMarks(cm) {\n    this.clearCodeMirrorMarks(cm)\n    for(let ea of this) {\n      ea.codeMirrorMark(cm)\n    }\n  }\n\n\n  clone() {\n    var r =  AnnotationSet.fromJSON(this.toJSON());\n    r.lastVersion = this.lastVersion // keep meta information\n    return r\n  }\n\n  static fromJSON(json) {\n    return new AnnotationSet(JSON.parse(json));\n  }\n\n  static async fromURL(url, version) {\n    var source = await lively.files.loadFile(url, version)\n    return this.fromJSON(JSON.parse(source))\n  }\n\n \n  livelyInspect(contentNode, inspector) {\n    if (this.list) contentNode.appendChild(inspector.display(this.list, false, \"list\", this));\n    if (this.textVersion) contentNode.appendChild(inspector.display(this.textVersion, false, \"textVersion\", this));\n    if (this.textContent) contentNode.appendChild(inspector.display(this.textContent, false, \"textContent\", this));\n  \n  }\n}\n\n\nexport class AnnotatedText {\n  \n  constructor(text, annotations) {\n    this.text = text || \"\"\n    this.annotations = new AnnotationSet()\n    if (annotations instanceof AnnotationSet) {\n      this.annotations = annotations\n    } else if (_.isString(annotations)) {\n      annotations.split(\"\\n\").forEach(ea => {\n        try {\n          var a = JSON.parse(ea)\n          this.annotations.add(a)\n        } catch(e) {\n          console.error(\"Annotation could not be parsed: \" + ea, e)\n        }\n      })\n    } else {\n      // JSON?\n    }\n    \n  }\n    \n  static async fromURL(fileURL, annotationsURL, annotationsVersion) {\n    var annotationsResp = await lively.files.loadFileResponse(annotationsURL, annotationsVersion)\n    var annotations = AnnotationSet.fromJSONL((await annotationsResp.text()))\n    annotations.fileURL = fileURL\n    annotations.annotationsURL = annotationsURL\n    annotations.lastVersion = annotationsResp.headers.get(\"fileversion\")\n    debugger\n    // hopefully we have the full text content... \n    if (annotations.textContent) {\n      var text = annotations.textContent         \n    } else {      \n      // if not, we can try to get it...\n      var textResp = await lively.files.loadFileResponse(fileURL, annotations.textVersion || annotationsVersion)\n      if (textResp.status !== 200) {\n        throw new Error(\"[annotations] could not load reference text for annotations\")\n      }\n      text = await textResp.text()\n      debugger\n      annotations.textVersion = textResp.headers.get(\"fileversion\")\n      annotations.textContent = text\n    }\n    var annotatedText = new AnnotatedText(text, annotations)    \n    return annotatedText \n  }  \n  \n  async saveToURL(fileURL, annotationsURL) {\n    await lively.files.saveFile(fileURL, this.text) \n    await lively.files.saveFile(annotationsURL, this.annotations.toJSONL()) \n  }\n  \n  equals(otherText) {\n    if (!otherText) return false\n    if (!otherText.annotations) return false\n    return this.text == otherText.text && this.annotations.equals(otherText.annotations)\n  }\n  \n  \n  // set text and upate annotations\n  setText(string, version) {\n    var oldText = this.text\n    this.text = string\n    if (version) {\n      // #TODO find last online commited version (e.g. uploaded to GitHub) that will not be squashed...\n      // this.annotations.syncedTextVersion = version\n      this.annotations.textVersion = version\n    }\n    this.annotations.textContent = string // we cannot rely on the version alone\n    let textDiff = dmp.diff_main(oldText, this.text);\n    this.annotations.applyTextDiff(textDiff)\n  }\n  \n  toHTML() {\n    return this.annotations.toXML(this.text)\n  }\n  \n  clearCodeMirrorMarks(cm) {\n    return this.annotations.clearCodeMirrorMarks(cm)\n  }\n  \n  static fromHTML(html) {\n    \n    var annotations = new AnnotationSet();\n    \n    var string = \"\"\n  \n    function visit(node, notfirst) {\n      if (!node || !node.childNodes) return;\n      if (node instanceof Text) {\n        string += node.textContent\n      } else {\n        if (notfirst) {\n          var annotation = new Annotation({\n            from: string.length, \n            to: string.length + node.textContent.length, \n            name: node.localName})\n          annotations.add(annotation)\n        }\n        // for (let attr of node.attributes) {\n        //   //  TODO\n        // }\n      }\n      for(let ea of node.childNodes) {\n        visit(ea, true)\n      }\n    }\n    \n    var parser = new DOMParser();\n    var doc = parser.parseFromString(html,\"text/html\");\n    visit(doc.body)\n    var annotatedText = new AnnotatedText(string, annotations);\n    return annotatedText\n  }\n  \n  clone() {\n    return new AnnotatedText(this.text, this.annotations.clone())\n  }\n  \n  \n  // Example: AnnotationSet.getGitMergeBase(\"https://lively-kernel.org/lively4\",  \"lively4-dummyA\", \"HEAD\", \"fd956\")\n  static async getGitMergeBase(serverURL, repositoryName, versionA, versionB) {\n    var github = Github.current()\n    var headers = new Headers({\n      \"gitusername\":          github.username,\n      \"gitpassword\":          github.token, \n      \"gitemail\":             github.email,\n      \"gitrepository\":        repositoryName,\n      gitversiona: versionA,\n      gitversionb: versionB,\n    })\n\n    return fetch(serverURL + \"/_git/mergebase\", {\n      headers: headers\n    }).then(r => r.text())    \n  }\n\n  static async solveAnnotationConflict(textURL, annotationURL) {\n    var sourceWithConflict = await annotationURL.fetchText() \n    \n    var serverURL = lively.files.serverURL(textURL)\n    var repositoryName = lively.files.repositoryName(textURL)\n    \n    \n    if (!serverURL || !repositoryName) throw new Error(\"Can only merge conflicts lively repository\")\n    \n    var versions = _.uniq(sourceWithConflict.split(\"\\n\")\n      .filter(ea => ea.match(/^(<<<<<<<)|(>>>>>>>) /))\n      .map(ea => ea.replace(/^(<<<<<<<)|(>>>>>>>) /, \"\")))\n\n    if (versions.length == 0) return // nothing to do\n    \n    if (versions.length != 2) throw new Error(\"merge  != 2 not support yet\")\n    var versionA= versions[0]\n    var versionB = versions[1]\n    \n        \n    // use git to find a common ancestor for merging:\n    //   lively4@livelygraph:~/lively4/lively4-dummyA$ git merge-base HEAD fd956\n    //   7d66773a9d35de3c95b0478b2fccf70c97c0061a\n\n\n    var versionBase = await this.getGitMergeBase(serverURL, repositoryName, versionA, versionB)\n    var a = await this.fromURL(textURL, annotationURL, versionA)\n    var b = await this.fromURL(textURL, annotationURL, versionB)\n    var base = await this.fromURL(textURL, annotationURL, versionBase)\n\n    // update the index positions of to fit text of a\n    b.setText(a.text)\n    base.setText(a.text) \n    \n    var mergedAnnotations = a.annotations.merge(b.annotations, base.annotations) \n    \n    \n    mergedAnnotations.textVersion = a.annotations.textVersion\n    mergedAnnotations.textContent = a.text\n\n    return new AnnotatedText(a.text, mergedAnnotations)\n  }\n}\n\n"}