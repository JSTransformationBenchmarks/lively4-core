{"type":"Reference","version":"ce068c8fad0881a9f3c19d4824fb294fe0025c97","content":"/*MD\n# Lively 4 Text Editor\n\n[doc](../../../doc/tools/editor.md)\n\n - simple load/save/navigate UI, that can be disabled to use elsewhere, e.g. container\n - updates change indicator while when editting,loading, and saving\n \n![](lively-editor.png){height=200} \n \n \nWe have to many objects called \"editor\", because they wrap around and FACADE each other.\n\n- (babylonian-programming-editor)\n - lively-editor\n   - lively-code-mirror\n     - cm CodeMirror object\n \n![](../../../doc/figures/editors.drawio)\n\nMD*/\n\nimport Strings from \"src/client/strings.js\"\nimport Morph from 'src/components/widgets/lively-morph.js'\nimport moment from \"src/external/moment.js\"\nimport diff from 'src/external/diff-match-patch.js'\nimport components from \"src/client/morphic/component-loader.js\"\nimport {pt} from \"src/client/graphics.js\"\nimport {getObjectFor, updateEditors} from \"utils\";\nimport files from \"src/client/files.js\"\n\nimport {AnnotatedText, Annotation, default as AnnotationSet} from \"src/client/annotations.js\"\nimport ContextMenu from 'src/client/contextmenu.js'\n\nexport default class Editor extends Morph {\n\n  /*MD ## Setup MD*/\n  \n  async initialize() {\n    var container = this.get(\".container\");\n\t\tthis.versionControl = this.shadowRoot.querySelector(\"#versionControl\");\n    \n    var editor = document.createElement(\"lively-code-mirror\")\n    editor.id = \"editor\"; // this is important to do before opening \n    await components.openIn(container, editor);\n    editor.setAttribute(\"overscroll\", \"contain\")\n    editor.setAttribute(\"wrapmode\", true)\n    editor.setAttribute(\"tabsize\", 2)\n\n    editor.doSave = async (text) => {\n      await this.saveFile(); // CTRL+S does not come through...    \n    };\n    \n    \n    this.addEventListener(\"drop\", evt => {\n      this.onDrop(evt)\n    })       \n    \n    this.get(\"lively-version-control\").editor = editor\n\n    this.registerButtons();\n    var input = this.get(\"#filename\");\n    \n    input.addEventListener(\"keyup\", event => {\n      if (event.keyCode == 13) { // ENTER\n        this.onFilenameEntered(input.value);\n      }\n    });\n    var url = this.getAttribute(\"url\") \n    if (url) {\n      this.setURL(url)\n    }\n    \n    container.dispatchEvent(new Event(\"initialized\"));   \n    editor.addEventListener('change', () => {\n      this.onTextChanged();\n    });\n    \n    this.addEventListener(\"paste\", evt => this.onPaste(evt))\n    this.addEventListener('contextmenu', evt => this.onContextMenu(evt), false);  \n    \n    // wait for CodeMirror for adding custom keys\n    await  editor.editorLoaded()\n    editor.registerExtraKeys({\n      \"Alt-P\": cm => {\n        // lively.notify(\"toggle widgets\")\n        this.toggleWidgets();\n      },\n      \n      \"Ctrl-Alt-P\": cm => {\n        // #TODO how can we have custom snippets?\n        this.currentEditor().replaceSelection(`/*MD MD*/`)\n        this.currentEditor().execCommand(`goWordLeft`)\n      }\n\n    })\n  }\n  \n  updateChangeIndicator() {\n    if (!this.lastText) return;\n    var newText = this.currentEditor().getValue();\n    if (newText != this.lastText) {\n      this.get(\"#changeIndicator\").style.backgroundColor = \"rgb(220,30,30)\";\n      this.textChanged = true;\n    } else {\n      if (this.annotatedText && !this.annotatedText.equals(this.lastAnnotatedText)) {\n        this.get(\"#changeIndicator\").style.backgroundColor = \"rgb(20,20,220)\";  \n        this.textChanged = false;\n      } else {\n        this.get(\"#changeIndicator\").style.backgroundColor = \"rgb(200,200,200)\";\n        this.textChanged = false;\n      }\n    }\n  }\n  \n  updateOtherEditors() {\n    console.warn('updateEditors')\n    const url = this.getURL().toString();\n    updateEditors(url, [this]);\n  }\n  \n  updateEditorMode() {\n    var url = this.getURL();\n    if (!url) return;\n    var editorComp = this.get(\"#editor\");\n    if (editorComp && editorComp.changeModeForFile) {\n      editorComp.changeModeForFile(url.pathname);\n    }\n  }\n  /*MD ## Event Handlers MD*/\n  \n  onTextChanged() {\n    this.updateChangeIndicator();\n  }\n\n  onSaveButton() {\n    this.saveFile();\n  }\n  \n  onLoadButton() {\n    this.loadFile();\n  }\n  \n  onVersionsButton() {\n    this.toggleVersions();\n  }\n  \n  onLoadVersionButton() {\n    this.loadFile(this.currentVersion());\n  }\n\n  onCloseVersionsButton() {\n    this.toggleVersions()\n  }\n  \n  \n  onPaste(evt) {\n    if(this.insertDataTransfer(evt.clipboardData, undefined, true)) {\n      evt.stopPropagation()\n      evt.preventDefault();\n    }\n  }\n  \n  async onBrowse() {\n    lively.openBrowser(this.getURLString())\n  }\n  \n  async onDrop(evt) {\n    \n    if(this.insertDataTransfer(evt.dataTransfer, evt, false)) {\n      evt.stopPropagation()\n      evt.preventDefault();\n    }\n  }\n  \n  onContextMenu(evt) {\n    if (!evt.shiftKey) {\n      evt.stopPropagation();\n      evt.preventDefault();\n      var menu = new ContextMenu(this, [\n          [\"<b>Annotations</b>\", this.annotatedText ? () => this.enableAnnotations() : null],\n          [\"mark <span style='background-color: yellow'>yellow</span>\", () => this.onAnnotationsMarkColor(\"yellow\")],\n          [\"mark <span style='background-color: blue'>blue</span>\", () => this.onAnnotationsMarkColor(\"blue\")],\n          [\"mark <span style='background-color: red'>red</span>\", () => this.onAnnotationsMarkColor(\"red\")],\n          [\"clear\", () => this.onAnnotationsClear()],\n        ]);\n      menu.openIn(document.body, evt, this);\n      return \n    }\n  }\n  \n  /*MD ## Getters/Setters MD*/\n  \n  getVersionWidget() {\n    var myWindow = lively.findWindow(this)\n    if (myWindow) {\n      var versionControl = myWindow.querySelector(\"#versionControl\")\n    }\n    return versionControl.get(\"#versions\")  \n  }\n  \n  currentVersion() {\n    var selection = this.getVersionWidget().selection;\n    if (selection) return selection.version;\n  }\n  \n  async onFilenameEntered() {\n    this.setAttribute(\"url\", this.getURLString())\n    await this.loadFile();\n    this.dispatchEvent(new CustomEvent(\"url-changed\", {detail: { url: this.getURLString() }}));\n  }\n\n  getMountURL() {\n    return \"https://lively4/sys/fs/mount\";\n  }\n\n  currentEditor() {\n    return this.get('#editor').editor;\n  }\n  \n  getURL() {\n    try {\n      return new URL(this.getURLString());\n    } catch(e) {\n      return undefined\n    }\n  }\n\n  getURLString() {\n    return this.getSubmorph('#filename').value;\n  }\n\n  setURL(urlString) {\n    if (!urlString) {\n      this.getSubmorph(\"#filename\").value = \"\";\n    } else {\n      var url = new URL(urlString);\n      this.getSubmorph(\"#filename\").value = url.href;\n    }\n    \n    this.dispatchEvent(new CustomEvent(\"url-changed\", {detail: {url: urlString}}))\n  }\n\n  setText(text, preserveView) {\n    text = text.replace(/\\r\\n/g, \"\\n\") // code mirror changes it anyway\n    this.lastText = text;\n    var codeMirror = this.currentEditor();\n    var cur = this.getCursor()\n    var scroll = this.getScrollInfo()\n\n    \n    if (codeMirror) {\n      if (!this.isCodeMirror()) {\n          var oldRange = this.currentEditor().selection.getRange()\n      }\n\n      this.updateChangeIndicator();\n      codeMirror.setValue(text);\n      if (codeMirror.resize) codeMirror.resize();\n      this.updateEditorMode();\n      \n      this.showEmbeddedWidgets()\n      \n    } else {\n      // Code Mirror\n      this.get('#editor').value = text\n    }\n    \n    // To solve \"empty editor after Ctrl+Z\" bug clear undo history of Codemirror after initial file loading \n    this.clearHistory()\n    \n    if (preserveView) {\n      this.setScrollInfo(scroll)\n      this.setCursor(cur)\n      if (!this.isCodeMirror()) {\n        this.currentEditor().selection.setRange(oldRange)\n      }\n    }\n    return text\n  }\n  \n  getText() {\n    return this.get('#editor').value \n  }\n  \n  getScrollInfo() {\n    if (!this.isCodeMirror()) return \n    return this.withEditorObjectDo(editor => editor.getScrollInfo())\n  }\n  \n  setScrollInfo(info) {\n    if (!this.isCodeMirror()) return \n    return this.withEditorObjectDo(editor => editor.scrollTo(info.left, info.top))\n  }\n  \n  getCursor() {\n    if (!this.isCodeMirror()) return \n    return this.withEditorObjectDo(editor => editor.getCursor())\n  }\n  \n  setCursor(cur) {\n    if (!cur || !this.isCodeMirror()) return \n    return this.withEditorObjectDo(editor => editor.setCursor(cur))\n  }  \n  \n  isCodeMirror() {\n    return this.get(\"#editor\").tagName == \"LIVELY-CODE-MIRROR\"\n  }\n  \n  /*MD ## Get UI Elements MD*/\n  \n  livelyEditor() {\n    return this  \n  }\n  \n  livelyCodeMirror() {\n    return this.get('#editor')\n  }\n  \n  // #deprecated\n  withEditorObjectDo(func) {\n    var editor = this.currentEditor()\n    if (editor) {\n      return func(editor)\n    }    \n  }\n\n  // #refactor #generalize?\n  async awaitEditor() {\n    while(!editor) {\n      var editor = this.currentEditor()\n      if (!editor) {\n        await lively.sleep(10) // busy wait\n      }\n    }\n    return editor\n  }\n\n  /*MD ## Files MD*/\n  \n  async loadFile(version) {\n    var url = this.getURL();\n    \n    // console.log(\"load \" + url);\n    this.updateEditorMode();\n\n    try {\n      var response = await fetch(url, {\n        headers: {\n          fileversion: version\n        }\n      })\n      // remember the commit hash (or similar version information) if loaded resource\n      this.lastVersion = response.headers.get(\"fileversion\");\n        // lively.notify(\"loaded version \" + this.lastVersion);\n      var text = await response.text();\n      var result =  this.setText(text, true); \n    } catch(e) {\n        lively.notify(\"Could not load file \" + url +\"\\nMaybe next time you are more lucky?\");\n        return \"\"\n    }\n    this.dispatchEvent(new CustomEvent(\"loaded-file\", {detail: {\n          \"url\": url,\n          \"text\": result,\n          \"version\": this.lastVersion}})); \n    \n\n    await this.checkAndLoadAnnotations()\n    \n    if (this.postLoadFile) {\n      result = await this.postLoadFile(result) // #TODO babylonian programming requires to adapt editor behavior\n    }\n    \n    return result\n  }\n  \n  clearHistory() {\n    this.livelyCodeMirror().clearHistory()\n  }\n\n  async checkAndLoadAnnotations() {\n    if(await lively.files.exists(this.getAnnotationsURL())) {\n      this.enableAnnotations()   \n    } else {\n      this.disableAnnotations()   \n    }\n  }\n  async saveFile() {\n    var url = this.getURL();\n    // console.log(\"save \" + url + \"!\");\n    // console.log(\"version \" + this.latestVersion);\n    var data = this.currentEditor().getValue();\n    if (this.preSaveFile) {\n      data = await this.preSaveFile(data)\n    }\n  \n    var urlString = url.toString();\n    if (urlString.match(/\\/$/)) {\n      return fetch(urlString, {method: 'MKCOL'});\n    } else {\n      window.LastData = data\n      \n      var headers = {}\n      if (this.lastVersion) {\n        headers.lastversion = this.lastVersion\n      }\n      if (urlString.match(/\\.svg$/)) {\n        headers['Content-Type'] = 'image/svg+xml'\n      }\n      \n      \n        /*MD ### Example \n```javascript\n  fetch(\"https://lively-kernel.org/lively4/lively4-dummy/foo/hello2.txt\", {\n  method: \"PUT\",\n  body: \"hello world\"\n}).then(r => r.text())\n```\n  ```\n {\n  \"type\": \"file\",\n  \"name\": \"foo/hello2.txt\",\n  \"size\": 11,\n  \"version\": \"716c0289ecba04604307d33734285314ab783235\",\n  \"modified\": \"2020-02-19 14:21:03\"\n}\n  ```\n  MD*/\n      try {\n        var response = await fetch(urlString, {\n          method: 'PUT', \n          body: data,\n          headers: headers\n        })\n        // console.log(\"edited file \" + url + \" written.\");\n        var newVersion = response.headers.get(\"fileversion\");\n        var conflictVersion = response.headers.get(\"conflictversion\");\n        // lively.notify(\"LAST: \" + this.lastVersion + \" NEW: \" + newVersion + \" CONFLICT:\" + conflictVersion)\n        if (conflictVersion) {\n          return this.solveConflict(conflictVersion, newVersion);\n        }\n        if (newVersion) {\n          // lively.notify(\"new version \" + newVersion);\n          this.lastVersion = newVersion;\n        }\n        lively.notify(\"saved file\", url );\n        this.lastText = data;\n        this.lastAnnotatedText = this.annotatedText\n        this.updateChangeIndicator();\n        this.updateOtherEditors();\n\n        var stats = {version: newVersion}\n\n        this.dispatchEvent(new CustomEvent(\"saved-file\", {detail: {\n          \"url\": urlString,\n          \"text\": data,\n          \"version\": this.lastVersion}})); \n        \n        return stats\n\n      } catch(e) {\n         lively.notify(\"Could not save file\" + url +\"\\nMaybe next time you are more lucky?:\", response);\n         throw new Error(\"LivelyEditor save failed:\" + e);\n        // don't catch here... so we can get the error later as needed...\n      }\n    }\n  }\n  \n  /*MD ## Merging MD*/\n  \n  threeWayMerge(a,b,c) {\n    var dmp = new diff.diff_match_patch();\n    var diff1 = dmp.diff_main(a, b);\n    var diff2 = dmp.diff_main(a, c);\n    \n    var patch1 = dmp.patch_make(diff1);\n    var patch2 = dmp.patch_make(diff2);\n    var merge = dmp.patch_apply(patch1.concat(patch2), a);\n    // #TODO handle conflicts detected in merge\n    return merge[0];\n  }\n\n  highlightChanges(otherText) {\n    var editor = this.currentEditor();\n    var myText = editor.getValue(); // data\n    var dmp = new diff.diff_match_patch();\n    var d = dmp.diff_main(otherText, myText);\n    var index = 0;\n    for (var ea of d) {\n      var change = ea[0];\n      var text = ea[1];\n      index = this.highlightChange(change, editor, text, index);\n    }\n  }  \n\n  highlightChange(change, editor, text, index) {\n    if (change != 0) {\n      var cm = editor;\n      var toPos;\n      var backgroundColor;\n      let marker;\n      let widget = <span>{text}</span>;\n      let targetColor = \"black\";\n      if (change == 1) {\n        // Added \n        toPos = cm.posFromIndex(index + text.length);\n        backgroundColor = \"green\";\n        try {\n          marker = cm.markText(cm.posFromIndex(index), toPos, { replacedWith: widget });\n        } catch(e) {\n          console.warn(\"[lively-editor] Could not mark change\");\n        }\n      } else {\n        backgroundColor = \"red\";\n        targetColor = \"transparent\";\n        try {\n          marker = cm.setBookmark(cm.posFromIndex(index), { widget: widget });\n        } catch(e) {\n          console.warn(\"[lively-editor] Could not set bookmark\");\n        }\n      }\n      var animation = widget.animate([{ background: backgroundColor, color: \"black\" }, { background: \"transparent\", color: targetColor }], {\n        duration: 3000\n      });\n      animation.onfinish = () => marker.clear();\n    } else {\n\n      index += text.length;\n    }\n\n    return index;\n  }\n\n  \n  /*\n   * solveConflict\n   * use three-way-merge\n   */\n  async solveConflict(otherVersion, newVersion) {\n    var conflictId = `conflic-${otherVersion}-${newVersion}`;\n    if (this.solvingConflict == conflictId) {\n      lively.error(\"Sovling conflict stopped\", \"due to recursion: \" + this.solvingConflict);\n      return;\n    }\n    if (this.solvingConflict) {\n      lively.warn(\"Recursive Solving Conflict\", \"\" + this.solvingConflict + \" and now: \" + conflictId);\n      return;\n    }\n\n    lively.notify(\"Solve Conflict between: \" + otherVersion + `and ` + newVersion);\n    var parentText = this.lastText; // \n    // load from conflict version\n    let url = this.getURL();\n    var otherText = await fetch(url, {\n      headers: { fileversion: otherVersion }\n    }).then(r => r.text());\n    var myText = this.currentEditor().getValue(); // data\n\n    // #TODO do something when actual conflicts occure?\n    var mergedText = this.threeWayMerge(parentText, myText, otherText);\n    this.setText(mergedText, true);\n    this.highlightChanges(myText);\n    this.lastVersion = otherVersion;\n    this.solvingConflict = conflictId;\n    let stats = {}\n    try {\n      // here it can come to infinite recursion....\n      stats = await this.saveFile();\n    } finally {\n      this.solvingConflict = false;\n    }\n    if (stats) {\n      var mergedVersion = stats.version\n      this.dispatchEvent(new CustomEvent(\"solved-conflict\", {detail: {\n        \"url\": url,\n        \"other-version\": otherVersion,\n        \"other-text\": otherText,\n        \"my-version\": newVersion,\n        \"my-text\": myText,\n        \"text\": mergedText,\n        \"version\": mergedVersion}}));      \n    } else {\n      // could not save file... :-(\n    }\n    \n  }\n  \n  /*MD ## Editor MD*/\n\n  showToolbar() {\n    this.getSubmorph(\"#toolbar\").style.display = \"\";\n  }\n  \n  hideToolbar() {\n    this.getSubmorph(\"#toolbar\").style.display = \"none\";\n  }\n\n  toggleVersions() {\n    var editor = this.shadowRoot.querySelector(\"#editor\");\n\n    if (this.versionControl.style.display == \"block\") {\n      this.versionControl.remove()\n      this.versionControl.style.display = \"none\";\n      if (editor.editView) {\n        editor.editView(); // go back into normal editing...\n      }\n    } else {\n      var myWindow = lively.findWindow(this)\n      if (myWindow.isWindow) {\n        myWindow.get(\".window-content\").style.overflow = \"visible\"\n      }\n      myWindow.appendChild(this.versionControl)\n\n      this.versionControl.style.display = \"block\";\n      this.versionControl.style.backgroundColor = \"gray\";\n            \n      this.versionControl.querySelector(\"#versions\").showVersions(this.getURL());\n      lively.setGlobalPosition(this.versionControl, \n        lively.getGlobalPosition(this).addPt(pt(lively.getExtent(this.parentElement).x,0)));\n      // we use \"parentElement\" because the extent of lively-editor is broken #TODO\n      lively.setExtent(this.versionControl, pt(400, 500))\n      this.versionControl.style.zIndex = 10000;\n\n    }\n  }\n  \n  find(pattern) {\n    var editor = this.get('#editor')\n    if (editor) {\n      editor.find(pattern)\n    }\n  }\n  /*MD ## Copy and Paste MD*/\n  \n  insertDataTransfer(dataTransfer, evt, generateName) {\n    // #CopyAndPaste mild code duplication with #Clipboard \n    \n    var items = dataTransfer.items;\n    if (items.length> 0) {\n      for (var index in items) {\n        var item = items[index];\n        if (item.kind === 'file') {\n          this.pasteFile(item, evt, generateName) \n          return true\n        }\n        if (item.type == 'lively/element') {\n          \n          item.getAsString(data => {\n            var element = getObjectFor(data)\n            if (element.localName == \"lively-file\") {\n              this.pasteDataUrlAs(element.url, \n                                  this.getURLString().replace(/[^/]*$/,\"\") + element.name, \n                                  element.name, \n                                  evt)\n            }\n            \n            // lively.showElement(element)\n          })\n          \n          return true\n        }\n      }\n    }\n  }\n\n  async pasteFile(fileItem, evt, generateName) {\n    var editor = this.currentEditor()\n    if (!editor) return;\n    var file = fileItem.getAsFile();\n    if (generateName) {\n      var name = \"file_\" + moment(new Date()).format(\"YYMMDD_hhmmss\")\n      var selection = editor.getSelection()\n      if (selection.length > 0 ) name = selection;\n      var filename = name + \".\" + fileItem.type.replace(/.*\\//,\"\")\n      filename = await lively.prompt(\"paste as... \", filename)\n      \n    } else {\n      filename = fileItem.getAsFile().name\n      if (filename.match(/\\.((md)|(txt))/)) return // are handle by code mirror to inline text // #Content vs #Container alt: value vs reference? #Journal\n      \n    }\n    if (!filename) return\n    \n    var newurl = this.getURLString().replace(/[^/]*$/,\"\") + filename \n    \n    var dataURL = await files.readBlobAsDataURL(file)  \n    this.pasteDataUrlAs(dataURL, newurl, filename, evt)\n  }\n  \n  async pasteDataUrlAs(dataURL, newurl, filename, evt) {\n\n    var blob = await fetch(dataURL).then(r => r.blob())\n    await files.saveFile(newurl, blob)\n    \n    this.withEditorObjectDo(editor => {\n      var text = encodeURIComponent(filename).replace(/%2F/g,\"/\")\n      if (this.getURLString().match(/\\.md/)) {\n        if (files.isVideo(filename)){\n          text = `<video autoplay controls><source src=\"${text}\" type=\"video/mp4\"></video>`\n        } else if (files.isPicture(filename)){\n          text = \"![](\" + text + \")\" // #ContextSpecificBehavior ?  \n        } else {\n          text = `[${text.replace(/.*\\//,\"\")}](${text})`\n          \n        }\n      }  \n\n      // #Hack... this is ugly... but seems the official way to do it\n      if (evt) {\n        var coords = editor.coordsChar({\n          left:   evt.clientX + window.scrollX,\n          top: evt.clientY + window.scrollY\n        });\n        editor.setSelection(coords)        \n      }\n      editor.replaceSelection(text, \"around\")      \n    })\n\n    lively.notify(\"uploaded \" + newurl)\n    \n    var navbar = lively.query(this, \"lively-container-navbar\")\n    if (navbar) navbar.update() \n  }\n  \n  /*MD ## Widgets MD*/\n  \n  async showEmbeddedWidgets() {\n    var url = this.getURL()\n    if (!url) return\n    var type = files.getEnding(url)\n    var codeMirrorComponent = this.get(\"lively-code-mirror\")\n    if (!codeMirrorComponent) return\n\n    if (type == \"js\") {\n      for(let m of Strings.matchAll(/\\/\\*((?:HTML)|(?:MD))(.*?)\\1\\*\\//, codeMirrorComponent.value)) {\n          var widgetName = \"div\"\n          var mode = m[1]\n          if (mode == \"MD\") {\n            widgetName = \"lively-markdown\"\n          }\n          let cm = codeMirrorComponent.editor,\n            // cursorIndex = cm.doc.indexFromPos(cm.getCursor()),\n            fromIndex = m.index,\n            toIndex = m.index + m[0].length\n                           \n          // if (cursorIndex > fromIndex && cursorIndex < toIndex) continue;\n          var from = cm.posFromIndex(fromIndex)\n          var to = cm.posFromIndex(toIndex)\n          let widget = await codeMirrorComponent.wrapWidget(widgetName, from, to)\n          // widget.style.border = \"2px dashed orange \"\n          widget.classList.add('inline-embedded-widget');\n          lively.removeEventListener('widget', widget)\n          // widget.style.padding = \"5px\"\n//           lively.addEventListener(\"context\", widget, \"contextmenu\", evt => {\n//             if (!evt.shiftKey) {\n//                const menuElements = [\n//                 [\"edit source\", () =>  widget.marker.clear()],\n//               ];\n//               const menu = new lively.contextmenu(this, menuElements)\n//               menu.openIn(document.body, evt, this)\n              \n//               evt.stopPropagation();\n//               evt.preventDefault();\n//               return true;\n//             }\n//           })\n        \n          if (mode == \"MD\") {\n            await widget.setContent(m[2])    \n            let container = lively.query(this, \"lively-container\")\n            if (container) {\n              lively.html.fixLinks(widget.shadowRoot.querySelectorAll(\"[href],[src]\"), \n                                    this.getURLString().replace(/[^/]*$/,\"\"),\n                                    url => container.followPath(url))\n            }\n          } else {\n            widget.innerHTML = m[2]\n            let container = lively.query(this, \"lively-container\")\n            if (container) {\n              lively.html.fixLinks(widget.querySelectorAll(\"[href],[src]\"), \n                                    this.getURL().toString().replace(/[^/]*$/,\"\"),\n                                    url => container.followPath(url))\n            }\n            \n          }\n      }\n     \n    }\n  }\n  \n  async hideEmbeddedWidgets() {\n    var codeMirrorComponent = this.get(\"lively-code-mirror\")\n    if (!codeMirrorComponent) return\n    codeMirrorComponent.editor.doc.getAllMarks()\n      .filter(ea => ea.widgetNode && ea.widgetNode.querySelector(\".lively-widget\")).forEach(ea => ea.clear())\n  }\n  \n  async toggleWidgets() {\n    var codeMirrorComponent = this.get(\"lively-code-mirror\")\n    if (!codeMirrorComponent) return\n    \n    // var cm = codeMirrorComponent.editor\n    // var cursorPos = cm.getCursor()\n    \n    var allWidgets = codeMirrorComponent.editor.doc.getAllMarks()\n      .filter(ea => ea.widgetNode && ea.widgetNode.querySelector(\".lively-widget\"))\n    if (allWidgets.length == 0) {\n      await this.showEmbeddedWidgets()\n    } else {\n      await this.hideEmbeddedWidgets()\n    }\n    \n    // scroll back into view...\n    // #TODO make it stable...\n    // await lively.sleep(1000)\n    // cm.setCursor(cursorPos)\n    // cm.scrollTo(null, cm.charCoords(cursorPos).top)\n  }\n  \n  async solveAnnotationConflict(newAnnotationsVersion, conflictingAnnotationsVersion) {\n    \n    var cm = await this.awaitEditor()\n    // solveConflict\n    var lastText = this.lastAnnotatedText\n    var text = this.annotatedText\n    \n    if (this.solvingAnnotationConflict) {\n      lively.warn(\"prevent endless recursion in solving conflict?\")\n      return\n    }\n    lively.notify(\"Conflicting Annotations: \" + conflictingAnnotationsVersion)\n    \n    var parentAnnotations = lastText.annotations\n    var otherAnnotationsSource = await fetch(this.getAnnotationsURL(), {\n      headers: { fileversion: conflictingAnnotationsVersion }\n    }).then(r => r.text());\n    var otherAnnotations = AnnotationSet.fromJSONL(otherAnnotationsSource)\n  \n    var myAnnotations = text.annotations\n    \n    debugger\n    // only when no text diff.....\n    var mergedAnnotations =   myAnnotations.merge(otherAnnotations, parentAnnotations)\n      \n    text.annotations = mergedAnnotations\n    text.annotations.renderCodeMirrorMarks(cm)\n    text.annotations.lastVersion = conflictingAnnotationsVersion  // is not textVersion\n    \n    this.solvingAnnotationConflict = true;\n    try {\n      await this.saveAnnotations()\n    } finally {\n      this.solvingAnnotationConflict = false;\n    }\n  }\n  \n  /*MD ## Annotations MD*/\n  \n  getAnnotationsURL() {\n    return this.getURLString() + \".l4a\"\n  } \n  \n  async saveAnnotations(textVersion=this.lastVersion) {\n    var cm = await this.awaitEditor()\n    var text = this.annotatedText\n    text.setText(this.getText(), textVersion)\n    \n    \n    var response = await fetch(this.getAnnotationsURL(), {\n      method: 'PUT', \n      body: text.annotations.toJSONL(),\n      headers: {lastversion: this.annotatedText.annotations.lastVersion}\n    })\n    \n    var writeResult = await response.text()\n    lively.notify(\"save annotations: \" + writeResult)\n    \n    var newAnnotationsVersion = response.headers.get(\"fileversion\");\n    var conflictAnnotationsVersion = response.headers.get(\"conflictversion\");  \n    if (conflictAnnotationsVersion) {\n        await this.solveAnnotationConflict(newAnnotationsVersion, conflictAnnotationsVersion)\n    } else {\n      this.annotatedText.annotations.lastVersion = newAnnotationsVersion \n    } \n    \n    this.annotatedText.annotations.renderCodeMirrorMarks(cm)\n  }\n  \n  async onAnnotationsMarkColor(color=\"yellow\") {\n    if (!this.annotatedText) {\n      await this.enableAnnotations()\n    }\n    \n    var cm = await this.awaitEditor()\n    var from  = cm.indexFromPos(cm.getCursor(\"from\"))\n    var to  = cm.indexFromPos(cm.getCursor(\"to\"))  \n    var annotation = new Annotation({from: from, to: to, name: \"color\", color: color})\n    this.annotatedText.setText(this.getText())\n    this.annotatedText.annotations.add(annotation)\n    annotation.codeMirrorMark(cm)\n    this.updateChangeIndicator()\n  }\n  \n  async onAnnotationsClear() {\n    var cm = await this.awaitEditor()\n    var from  = cm.indexFromPos(cm.getCursor(\"from\"))\n    var to  = cm.indexFromPos(cm.getCursor(\"to\"))\n    this.annotatedText.annotations.removeFromTo(from, to)\n    this.annotatedText.annotations.renderCodeMirrorMarks(cm) \n    this.updateChangeIndicator()\n  }  \n  \n  async loadAnnotations(text, version) {\n    var cm = await this.awaitEditor()\n    // load annotated text in the version that was  last annotated\n    this.annotatedText  = await AnnotatedText.fromURL(this.getURLString(), this.getAnnotationsURL())\n    // set current text and version, and update annotations accordingly \n    this.annotatedText.setText(text, version)\n    this.annotatedText.annotations.renderCodeMirrorMarks(cm)\n    this.lastAnnotatedText = this.annotatedText.clone()\n  }\n  \n  async disableAnnotations() { \n    if (this.annotatedText) {\n      this.annotatedText.clearCodeMirrorMarks(await this.awaitEditor())\n    }\n    lively.removeEventListener(\"annotations\", this)\n    delete this.annotatedText\n  }\n  \n  async enableAnnotations() { \n    lively.removeEventListener(\"annotations\", this)\n    lively.addEventListener(\"annotations\", this, \"loaded-file\", async evt => {\n      this.loadAnnotations(evt.detail.text, evt.detail.version) \n    })\n    lively.addEventListener(\"annotations\", this, \"saved-file\", async evt => {\n      this.saveAnnotations(evt.detail.version)\n    })\n    // lively.addEventListener(\"annotations\", this, \"solved-conflict\", evt => {\n    //   // we can ignore this, since it will be solved... by the editor\n    //   lively.notify(\"TEXT CONFLICT \" + evt.detail.version )\n    // })\n    await this.loadAnnotations(this.getText(), this.lastVersion) \n  }\n  \n  \n  /*MD ## Hooks MD*/\n\n  livelyExample() {\n    this.setURL(lively4url + \"/README.md\");\n    this.loadFile()\n  }\n  \n  livelyMigrate(obj) {\n\t\tif (obj.versionControl) obj.versionControl.remove();\n    this.setURL(obj.getURL());\n    this.loadFile();\n  }\n}"}